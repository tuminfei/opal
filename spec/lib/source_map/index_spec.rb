RSpec.describe Opal::SourceMap::Index do
  # describe '#segment_from_fragment' do
  #   it 'uses relative indexes' do
  #     fragments = [
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "/* Generated by Opal 0.11.1.dev */", sexp_type: :top),
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "\n", sexp_type: :top),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "(function(Opal) {", sexp_type: :top),
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "\n  ", sexp_type: :top),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "var self = Opal.top, $nesting = [], nil = Opal.nil, $$$ = Opal.const_get_qualified, $$ = Opal.const_get_relative, $breaker = Opal.breaker, $slice = Opal.slice;\n", sexp_type: :top),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "\n  ", sexp_type: :top),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "Opal.add_stubs(['$puts']);", sexp_type: :top),
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "\n  ", sexp_type: :top),
  #
  #       OpenStruct.new(line: 1, column: 0, source_map_name: nil, code: "\n  ", sexp_type: :begin),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: "self", code: "self", sexp_type: :self),
  #       OpenStruct.new(line: 1, column: 0, source_map_name: :puts, code: ".$puts", sexp_type: :send),
  #       OpenStruct.new(line: 1, column: 0, source_map_name: :puts, code: "(", sexp_type: :send),
  #       OpenStruct.new(line: 1, column: 5, source_map_name: "5", code: "5", sexp_type: :int),
  #       OpenStruct.new(line: 1, column: 0, source_map_name: :puts, code: ")", sexp_type: :send),
  #       OpenStruct.new(line: 1, column: 0, source_map_name: nil, code: ";", sexp_type: :begin),
  #       OpenStruct.new(line: 1, column: 0, source_map_name: nil, code: "\n  ", sexp_type: :begin),
  #
  #       OpenStruct.new(line: 3, column: 0, source_map_name: nil, code: "return ", sexp_type: :js_return),
  #       OpenStruct.new(line: nil, column: nil, source_map_name: "self", code: "self", sexp_type: :self),
  #       OpenStruct.new(line: 3, column: 0, source_map_name: :puts, code: ".$puts", sexp_type: :send),
  #       OpenStruct.new(line: 3, column: 0, source_map_name: :puts, code: "(", sexp_type: :send),
  #       OpenStruct.new(line: 3, column: 5, source_map_name: "6", code: "6", sexp_type: :int),
  #       OpenStruct.new(line: 3, column: 0, source_map_name: :puts, code: ")", sexp_type: :send),
  #       OpenStruct.new(line: 1, column: 0, source_map_name: nil, code: ";", sexp_type: :begin),
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "\n", sexp_type: :top),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "})(Opal);\n", sexp_type: :top),
  #
  #       OpenStruct.new(line: nil, column: nil, source_map_name: nil, code: "\n", sexp_type: :newline),
  #
  #     ]
  #
  #     subject = described_class.new(fragments, 'foo.rb', "puts 5\n\nputs 6")
  #     expect(subject.map.merge(mappings: nil)).to eq(
  #       version: 3,
  #       sourceRoot: '',
  #       sources: ['foo.rb'],
  #       sourcesContent: ["puts 5\n\nputs 6"],
  #       names: ['puts', '5', '6'],
  #       mappings: nil,
  #     )
  #     parsed_map = SourceMap::Map.from_json(subject.to_json)
  #     offset = -> line, column { OpenStruct.new(line: line, column: column) }
  #     offset_for = -> string {
  #       line_contents, line = subject.generated_code.split("\n", -1).to_enum.with_index.find do |contents, index|
  #         contents.include? string
  #       end
  #       next nil if line_contents.nil?
  #       column = line_contents.index(string)
  #       offset[line, column]
  #     }
  #     # original_position_for = -> offset {
  #     #   parsed_map.bsearch(offset)
  #     # }
  #     puts subject.to_json
  #     original_position_for = -> generated_offset {
  #       full_line = subject.absolute_mappings[generated_offset.line]
  #       p SEARCH_FOR: generated_offset, line: full_line
  #       segment = full_line.select do |segment|
  #         segment[0] >= generated_offset.column
  #       end.sort_by do |segment|
  #         segment[0] - generated_offset.column
  #       end.first
  #       puts segment
  #       offset[segment[2], segment[3]]
  #     }
  #     puts "     #{(0..80).map{|n| n % 10}.join}"
  #     subject.generated_code.each_line.with_index.to_a.map(&:reverse).each { |l| puts l }
  #     expect(offset_for['$puts(5)']).to eq(offset[6,7])
  #     expect(offset_for['5']).to eq(offset[6,13])
  #     expect(offset_for['$puts(6)']).to eq(offset[7,14])
  #     expect(offset_for['6']).to eq(offset[7,20])
  #
  #     puts subject.absolute_mappings
  #
  #     expect(original_position_for.(offset_for['puts(5)'])).to eq(offset[0,0])
  #     expect(original_position_for.(offset_for['5);'])).to eq(offset[0,5])
  #     expect(original_position_for.(offset_for['puts(6)'])).to eq(offset[2,0])
  #     expect(original_position_for.(offset_for['6);'])).to eq(offset[2,5])
  #
  #     # expect(subject.relative_mappings).to eq(
  #     #   # [generated_column, source_index, original_line, original_column, map_name_index]
  #     #   [],
  #     #   [],
  #     #   [],
  #     #   [],
  #     #   [],
  #     #   [],
  #     #   [
  #     #     [6, 0, 0, 0, 0],
  #     #     [6, 0, 0, 0, 0],
  #     #     [1, 0, 0, 5, 1],
  #     #   ]
  #     # ])
  #   end
  # end
end
